# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #

from Assert import assert_param_bool
from Bool import Bool
from BuildInfo import is_llcl_profiling_enabled, is_llcl_profiling_disabled
from Int import Int
from StringRef import StringRef

# ===----------------------------------------------------------------------===#
# trace_range_push
# ===----------------------------------------------------------------------===#


@interface
@always_inline
fn trace_range_push[level: Int](name: StringRef, detail: StringRef):
    """Push a trace event onto a per-thread stack of traces.
    Should be paired with calls to trace_range_pop().

    The modular stack needs to be configured with MODULAR_LLCL_MAX_PROFILING_LEVEL
    specifing the profiling level to profile at.

    The trace events will be written to the profiling file passed to the
    LLCL Runtime ctor.

    Args:
        name: name of the trace event (will be copied).
        detail: additional details about the trace event (will be copied).

    """
    ...


@implements(trace_range_push)
@always_inline
fn _trace_range_push_maybe_enabled[
    level: Int
](name: StringRef, detail: StringRef):
    """Pushes the trace range from the stack. This is only enabled if the LLCL
    profiling is enabled."""
    assert_param_bool[is_llcl_profiling_enabled[level.__as_mlir_index()]()]()
    _trace_range_push(name, detail)


@implements(trace_range_push)
@always_inline
fn _trace_range_push_disabled[level: Int](name: StringRef, detail: StringRef):
    assert_param_bool[is_llcl_profiling_disabled[level.__as_mlir_index()]()]


@always_inline
fn _trace_range_push(name: StringRef, detail: StringRef):
    """trace range is pushed regardless of value of wither profiling is enabled.
    This is useful during testings.

    trace_range_push() should be used instead if tracing needs to be
    conditionally enabled.
    """
    __mlir_op.`pop.external_call`[
        func : __mlir_attr.`@KGEN_CompilerRT_TimeTraceProfilerBegin`,
        _type:[],
    ](
        name.data.address,
        name.length.value,
        detail.data.address,
        detail.length.value,
    )


# ===----------------------------------------------------------------------===#
# trace_range_pop
# ===----------------------------------------------------------------------===#


@interface
@always_inline
fn trace_range_pop[level: Int]():
    """Pop a trace event off a per-thread stack of traces.
    Should be paired with calls to trace_range_push().

    PROFILING_ON must be set to True otherwise this is a noop that will be
    folded away.

    The trace events will be written to the profiling file passed to the
    LLCL Runtime ctor.
    """
    ...


@implements(trace_range_pop)
@always_inline
fn _trace_range_pop_maybe_enabled[level: Int]():
    """Pops the trace range from the stack. This is only enabled if the LLCL
    profiling is enabled."""
    assert_param_bool[is_llcl_profiling_enabled[level.__as_mlir_index()]()]()
    _trace_range_pop()


@implements(trace_range_pop)
@always_inline
fn _trace_range_pop_disabled[level: Int]():
    assert_param_bool[is_llcl_profiling_disabled[level.__as_mlir_index()]()]()


@always_inline
fn _trace_range_pop():
    """trace range is popped regardless of value of the profile_level.

    trace_range_pop() should be used instead if tracing needs to be
    conditionally enabled.
    """
    __mlir_op.`pop.external_call`[
        func : __mlir_attr.`@KGEN_CompilerRT_TimeTraceProfilerEnd`,
        _type:[],
    ]()


# ===----------------------------------------------------------------------===#
# Trace
# ===----------------------------------------------------------------------===#


struct Trace[level: Int]:
    fn __new__(name: StringRef) -> Trace[level]:
        return Trace[level](name, "")

    fn __new__(name: StringRef, detail: StringRef) -> Trace[level]:
        trace_range_push[level](name, detail)
        return Trace[level] {}

    fn __del__(self):
        trace_range_pop[level]()
