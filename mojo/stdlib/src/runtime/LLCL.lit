# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #

from Atomic import Atomic
from DType import DType
from Error import Error
from Int import Int
from Pointer import Pointer

alias typename = __mlir_type.`!kgen.mlirtype`


# ===----------------------------------------------------------------------===#
# num_cores
# ===----------------------------------------------------------------------===#


fn num_cores() -> Int:
    """Returns the number of cores on the system.

    Returns:
        Int: The number of cores on the system
    """
    return __mlir_op.`pop.external_call`[
        func : __mlir_attr.`@KGEN_CompilerRT_CoreCount`,
        _type : __mlir_type.index,
    ]()


# ===----------------------------------------------------------------------===#
# Async Context
# ===----------------------------------------------------------------------===#


struct AsyncContext:
    var chain: __mlir_type.index
    var runtime: Runtime


# ===----------------------------------------------------------------------===#
# CoroutineRef
# ===----------------------------------------------------------------------===#


struct CoroutineRef[type: typename]:
    alias _handle_type = __mlir_type[`!pop.coroutine<() -> `, type, `>`]
    alias _promise_type = __mlir_type[`!pop.struct<`, type, `>`]
    var _handle: _handle_type

    fn __new__(_handle: _handle_type) -> CoroutineRef[type]:
        """Create a reference to a coroutine from a builtin handle."""
        return CoroutineRef[type] {_handle: _handle}

    fn get_promise(self) -> Pointer[type]:
        """Get the pointer to the coroutine promise."""
        let promise: Pointer[_promise_type] = __mlir_op.`pop.coroutine.promise`(
            self._handle
        )
        return promise.bitcast[type]()

    fn get_async_ctx(self) -> Pointer[AsyncContext]:
        """Returns the pointer to the async context."""
        return (self.get_promise() + 1).bitcast[AsyncContext]()

    fn get_opaque_ctx(self) -> Pointer[__mlir_type.i8]:
        """Returns the pointer to the async context as an opaque pointer."""
        return self.get_async_ctx().bitcast[__mlir_type.i8]()


# ===----------------------------------------------------------------------===#
# Utility Functions
# ===----------------------------------------------------------------------===#


fn _coro_resume_fn(handle: __mlir_type.`!pop.coroutine<() -> ()>`):
    """This function is a generic coroutine resume function."""
    __mlir_op.`pop.coroutine.resume`(handle)


fn _get_coro_resume_fn() -> __mlir_type.`(!pop.coroutine<() -> ()>) -> !lit.none`:
    """Return the address to the generic coroutine resume function."""
    return __mlir_op.`kgen.addressof`[
        _type : [__mlir_type.`(!pop.coroutine<() -> ()>) -> !lit.none`],
        callee:_coro_resume_fn,
        paramDecls : __mlir_attr.`#kgen<param.decls[]>`,
    ]()


fn _init_async_ctx(ptr: Pointer[AsyncContext]):
    __mlir_op.`pop.external_call`[
        _type:[],
        func : __mlir_attr.`@KGEN_CompilerRT_LLCL_InitializeContext`,
    ](ptr.bitcast[__mlir_type.i8]().address)


fn _del_async_ctx(ptr: Pointer[AsyncContext]):
    __mlir_op.`pop.external_call`[
        _type:[],
        func : __mlir_attr.`@KGEN_CompilerRT_LLCL_DestroyContext`,
    ](ptr.bitcast[__mlir_type.i8]().address)


fn _async_and_then(
    hdl: __mlir_type.`!pop.coroutine<() -> ()>`, ptr: Pointer[AsyncContext]
):
    __mlir_op.`pop.external_call`[
        _type:[], func : __mlir_attr.`@KGEN_CompilerRT_LLCL_AndThen`
    ](_get_coro_resume_fn(), ptr.bitcast[__mlir_type.i8]().address, hdl)


fn _async_wait(ptr: Pointer[AsyncContext]):
    __mlir_op.`pop.external_call`[
        _type:[], func : __mlir_attr.`@KGEN_CompilerRT_LLCL_Wait`
    ](ptr.bitcast[__mlir_type.i8]().address)


# ===----------------------------------------------------------------------===#
# Runtime
# ===----------------------------------------------------------------------===#


struct Runtime:
    alias _id_type = __mlir_type.i8
    var _id: _id_type

    fn __new__() -> Runtime:
        """Construct an LLCL Runtime with the same number of threads as
        processor cores.
        """
        return Runtime(num_cores())

    fn __new__(numThreads: Int) -> Runtime:
        """Construct an LLCL Runtime with the specified number of threads."""
        let numThreadsI8 = __mlir_op.`pop.cast`[
            _type : __mlir_type.`!pop.scalar<si8>`
        ](numThreads.value)
        return __mlir_op.`pop.external_call`[
            _type : [__mlir_type.i8],
            func : __mlir_attr.`@KGEN_CompilerRT_LLCL_CreateRuntime`,
        ](numThreadsI8)

    fn __new__(compact_ptr: __mlir_type.i8) -> Runtime:
        return Runtime {_id: compact_ptr}

    fn __del__(self):
        """Destroys the LLCL Runtime. Note that this must be explicitly called
        when the Runtime goes out of scope.
        """
        __mlir_op.`pop.external_call`[
            _type:[], func : __mlir_attr.`@KGEN_CompilerRT_LLCL_DestroyRuntime`
        ](self._id)

    fn parallelism_level(self) -> Int:
        """Gets the parallism level of the Runtime."""
        return __mlir_op.`pop.external_call`[
            func : __mlir_attr.`@KGEN_CompilerRT_LLCL_ParallelismLevel`,
            _type : __mlir_type.`!pop.scalar<si32>`,
        ](self._id)

    fn run_task[
        type: typename
    ](self, handle: CoroutineRef[type]) -> Future[type]:
        """Run the coroutine as a task on the LLCL Runtime."""
        __mlir_op.`pop.external_call`[
            _type:[], func : __mlir_attr.`@KGEN_CompilerRT_LLCL_Execute`
        ](_get_coro_resume_fn(), handle, self._id)
        return handle

    fn init_and_run[
        type: typename
    ](self, handle: CoroutineRef[type]) -> Future[type]:
        """Run the coroutine as a task on the LLCL Runtime, scheduling it from a
        sync context.
        """
        var asyncCtx = handle.get_async_ctx().load()
        asyncCtx.runtime = self
        handle.get_async_ctx().store(asyncCtx)
        _init_async_ctx(handle.get_async_ctx())
        return self.run_task[type](handle)

    @staticmethod
    @always_inline
    fn get_current() -> Runtime:
        """When in an async context, retrieve the current active Runtime."""
        let curHdl: CoroutineRef[
            __mlir_type.index
        ] = __mlir_op.`pop.coroutine.handle`[
            _type : __mlir_type.`!pop.coroutine<() -> index>`
        ]()
        return curHdl.get_async_ctx().load().runtime


# ===----------------------------------------------------------------------===#
# Future
# ===----------------------------------------------------------------------===#


struct Future[type: typename]:
    var handle: CoroutineRef[type]

    fn get(self) -> type:
        """Get the future value."""
        return self.handle.get_promise().load()

    @nodebug_inline
    fn __new__(handle: CoroutineRef[type]) -> Future[type]:
        """Create a future from a coroutine handle."""
        return Future[type] {handle: handle}

    fn __del__(self):
        """Destroy the memory associated with a future. This must be manually
        called when a future goes out of scope.
        """
        _del_async_ctx(self.handle.get_async_ctx())
        __mlir_op.`pop.coroutine.destroy`(self.handle._handle)

    @always_inline
    fn __await__(self&) -> type:
        """Suspend the current async function until the future value becomes
        available. This function must be force inlined into the calling async
        function.
        """
        let curHdl = __mlir_op.`pop.coroutine.handle`[
            _type : __mlir_type.`!pop.coroutine<() -> ()>`
        ]()

        fn await_body():
            _async_and_then(curHdl, self.handle.get_async_ctx())

        __mlir_op.`pop.coroutine.await`[_region:["await_body"]]()
        return self.get()

    fn wait(self) -> type:
        """Block the current thread until the future value becomes available."""
        _async_wait(self.handle.get_async_ctx())
        return self.get()


# ===----------------------------------------------------------------------===#
# TaskGroup
# ===----------------------------------------------------------------------===#


struct TaskGroup:
    var ctx: AsyncContext
    var counter: Atomic[DType.index.value]

    fn __new__(rt: Runtime) -> TaskGroup:
        var ctx: AsyncContext
        ctx.runtime = rt
        _init_async_ctx(Pointer[AsyncContext].address_of(ctx))
        return TaskGroup {counter: 1, ctx: ctx}

    fn __del__(self&):
        _del_async_ctx(Pointer[AsyncContext].address_of(self.ctx))

    @staticmethod
    fn _get_decr_callback() -> __mlir_type[
        `(!pop.pointer<`, TaskGroup, `>) -> `, Int
    ]:
        return __mlir_op.`kgen.addressof`[
            _type : [__mlir_type[`(!pop.pointer<`, TaskGroup, `>) -> `, Int]],
            callee:_counter_decr,
            paramDecls : __mlir_attr.`#kgen<param.decls[]>`,
        ]()

    fn add_task[type: typename](self&, task: Future[type]):
        self.counter += 1
        __mlir_op.`pop.external_call`[
            _type:[], func : __mlir_attr.`@KGEN_CompilerRT_LLCL_AddTaskToGroup`
        ](
            Pointer[AsyncContext].address_of(self.ctx),
            _get_decr_callback(),
            task.handle.get_opaque_ctx(),
        )

    @always_inline
    fn _counter_decr(self&) -> Int:
        self.counter -= 1
        return self.counter.value

    @staticmethod
    fn await_body_impl(
        hdl: __mlir_type.`!pop.coroutine<() -> ()>`, tg&: TaskGroup
    ):
        _async_and_then(hdl, Pointer[AsyncContext].address_of(tg.ctx))
        if tg._counter_decr() == 0:
            _coro_resume_fn(hdl)

    @always_inline
    fn __await__(self&):
        let curHdl = __mlir_op.`pop.coroutine.handle`[
            _type : __mlir_type.`!pop.coroutine<() -> ()>`
        ]()

        fn await_body():
            await_body_impl(curHdl, self)

        __mlir_op.`pop.coroutine.await`[_region:["await_body"]]()

    fn wait(self&):
        if self._counter_decr() == 0:
            return
        _async_wait(Pointer[AsyncContext].address_of(self.ctx))
