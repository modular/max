# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #

from Atomic import Atomic
from Coroutine import Coroutine, _get_coro_resume_fn
from DType import DType
from Error import Error
from Int import Int
from Pointer import Pointer, DTypePointer
from StringRef import StringRef

alias typename = __mlir_type.`!kgen.mlirtype`


# ===----------------------------------------------------------------------===#
# num_cores
# ===----------------------------------------------------------------------===#


fn num_cores() -> Int:
    """Returns the number of cores on the system.

    Returns:
        Int: The number of cores on the system
    """
    return __mlir_op.`pop.external_call`[
        func : __mlir_attr.`@KGEN_CompilerRT_CoreCount`,
        _type : __mlir_type.index,
    ]()


# ===----------------------------------------------------------------------===#
# AsyncContext
# ===----------------------------------------------------------------------===#


@register_passable
struct Chain:
    """This is an opaque instance of the C++ class `AsyncValueRef<Chain>`, whose
    size is the same as the pointer width.
    """

    var storage: __mlir_type.index

    @always_inline("nodebug")
    fn __copy__(self) -> Self:
        return Self {storage: self.storage}


# FIXME(traits): This shouldn't be a register_passable type but we need this
# until we have traits for proper parametric types.
@register_passable
struct AsyncContext:
    """This struct models the coroutine context contained in every coroutine
    instance. The struct consists of a unary callback function that accepts a
    pointer argument. It is invoked with the second struct field, which is an
    opaque pointer. This struct is essentially a completion callback closure
    that is invokved by a coroutine when it completes and its results are made
    available.

    In async execution, a task's completion callback is to set its async token
    to available.
    """

    alias callback_fn_type = __mlir_type[`(`, Chain, `) -> !lit.none`]

    var callback: callback_fn_type
    var chain: Chain

    @staticmethod
    fn get_chain(ctx: Pointer[AsyncContext]) -> Pointer[Chain]:
        return __mlir_op.`lit.struct.gep`[
            _type : Pointer[Chain].pointer_type, field : __mlir_attr.`"chain"`
        ](ctx.address)

    @staticmethod
    fn complete(ch: Chain):
        var chMem = ch
        _async_complete(Pointer[Chain].address_of(chMem))


# ===----------------------------------------------------------------------===#
# LLCL C Shims
# ===----------------------------------------------------------------------===#


fn _init_llcl_chain(rt: Runtime, chain: Pointer[Chain]):
    __mlir_op.`pop.external_call`[
        _type:[],
        func : __mlir_attr.`@KGEN_CompilerRT_LLCL_InitializeChain`,
    ](rt.ptr, chain.address)


fn _del_llcl_chain(chain: Pointer[Chain]):
    __mlir_op.`pop.external_call`[
        _type:[],
        func : __mlir_attr.`@KGEN_CompilerRT_LLCL_DestroyChain`,
    ](chain.address)


fn _async_and_then(hdl: __mlir_type.`!pop.pointer<i8>`, chain: Pointer[Chain]):
    __mlir_op.`pop.external_call`[
        _type:[], func : __mlir_attr.`@KGEN_CompilerRT_LLCL_AndThen`
    ](_get_coro_resume_fn(), chain.address, hdl)


fn _async_execute[type: typename](handle: Coroutine[type], rt: Runtime):
    __mlir_op.`pop.external_call`[
        _type:[], func : __mlir_attr.`@KGEN_CompilerRT_LLCL_Execute`
    ](_get_coro_resume_fn(), handle._handle, rt.ptr)


fn _async_wait(chain: Pointer[Chain]):
    __mlir_op.`pop.external_call`[
        _type:[], func : __mlir_attr.`@KGEN_CompilerRT_LLCL_Wait`
    ](chain.address)


fn _async_complete(chain: Pointer[Chain]):
    __mlir_op.`pop.external_call`[
        _type:[], func : __mlir_attr.`@KGEN_CompilerRT_LLCL_Complete`
    ](chain.address)


# ===----------------------------------------------------------------------===#
# Runtime
# ===----------------------------------------------------------------------===#

# FIXME(traits): This shouldn't be a register_passable type but we need this
# until we have traits for proper parametric types.
@register_passable
struct Runtime:
    alias ptr_type = DTypePointer[DType.invalid.value]
    var ptr: ptr_type

    # TODO: Probably don't want the runtime to be implicitly copyable.
    @always_inline("nodebug")
    fn __copy__(self) -> Self:
        return Self {ptr: self.ptr}

    fn __init__() -> Runtime:
        """Construct an LLCL Runtime with the same number of threads as
        processor cores.
        """
        return Runtime(num_cores())

    fn __init__(numThreads: Int) -> Runtime:
        """Construct an LLCL Runtime with the specified number of threads."""
        return __mlir_op.`pop.external_call`[
            _type:[ptr_type],
            func : __mlir_attr.`@KGEN_CompilerRT_LLCL_CreateRuntime`,
        ](numThreads)

    fn __init__(numThreads: Int, profileFilename: StringRef) -> Runtime:
        """Construct an LLCL Runtime with the specified number of threads
        that writes tracing events to profileFilename.
        """
        return __mlir_op.`pop.external_call`[
            _type:[ptr_type],
            func : __mlir_attr.`@KGEN_CompilerRT_LLCL_CreateRuntimeWithProfile`,
        ](
            numThreads,
            profileFilename.data.address,
            profileFilename.length.value,
        )

    fn __init__(ptr: ptr_type) -> Runtime:
        return Runtime {ptr: ptr}

    fn __del__(self):
        """Destroys the LLCL Runtime. Note that this must be explicitly called
        when the Runtime goes out of scope.
        """
        __mlir_op.`pop.external_call`[
            _type:[], func : __mlir_attr.`@KGEN_CompilerRT_LLCL_DestroyRuntime`
        ](self.ptr)

    fn parallelism_level(self) -> Int:
        """Gets the parallism level of the Runtime."""
        return __mlir_op.`pop.external_call`[
            func : __mlir_attr.`@KGEN_CompilerRT_LLCL_ParallelismLevel`,
            _type : __mlir_type.`!pop.scalar<si32>`,
        ](self.ptr)

    fn create_task[type: typename](self, handle: Coroutine[type]) -> Task[type]:
        """Run the coroutine as a task on the LLCL Runtime."""
        let ctx = handle.get_ctx[AsyncContext]()
        _init_llcl_chain(self, AsyncContext.get_chain(ctx))
        let callbackPtr: Pointer[
            AsyncContext.callback_fn_type
        ] = __mlir_op.`lit.struct.gep`[
            _type : Pointer[AsyncContext.callback_fn_type].pointer_type,
            field : __mlir_attr.`"callback"`,
        ](
            ctx.address
        )
        callbackPtr.store(
            __mlir_op.`kgen.addressof`[
                _type : [AsyncContext.callback_fn_type],
                callee : AsyncContext.complete,
                paramDecls : __mlir_attr.`#kgen<param.decls[]>`,
            ]()
        )
        _async_execute(handle, self)
        return Task[type] {handle: handle}

    fn run[type: typename](self, handle: Coroutine[type]) -> type:
        let t = self.create_task(handle)
        let result = t.wait()
        t.__del__()
        return result


# ===----------------------------------------------------------------------===#
# Task
# ===----------------------------------------------------------------------===#


struct Task[type: typename]:
    var handle: Coroutine[type]

    # TODO: This should not be implicitly copyable when we have ownership all
    # set up!
    fn __copy__(self) -> Self:
        return Self {handle: self.handle}

    fn get(self) -> type:
        """Get the task's result value."""
        return self.handle.get()

    fn __del__(self):
        """Destroy the memory associated with a task. This must be manually
        called when a task goes out of scope.
        """
        let ctx = self.handle.get_ctx[AsyncContext]()
        let chainPtr: Pointer[Chain] = __mlir_op.`lit.struct.gep`[
            _type : Pointer[Chain].pointer_type, field : __mlir_attr.`"chain"`
        ](ctx.address)
        _del_llcl_chain(chainPtr)
        self.handle.__del__()

    @always_inline
    fn __await__(self) -> type:
        """Suspend the current async function until the task completes and its
        result becomes available. This function must be force inlined into the
        calling async function.
        """
        let cur_hdl = __mlir_op.`pop.coroutine.opaque_handle`()

        __mlir_region await_body():
            _async_and_then(
                cur_hdl,
                AsyncContext.get_chain(self.handle.get_ctx[AsyncContext]()),
            )

        __mlir_op.`pop.coroutine.await`[_region:["await_body"]]()
        return self.get()

    fn wait(self) -> type:
        """Block the current thread until the future value becomes available."""
        _async_wait(AsyncContext.get_chain(self.handle.get_ctx[AsyncContext]()))
        return self.get()


# ===----------------------------------------------------------------------===#
# TaskGroup
# ===----------------------------------------------------------------------===#

# FIXME(traits): This shouldn't be a register_passable type but we need this
# until we have traits for proper parametric types.
@register_passable
struct TaskGroupContext:
    alias tg_callback_fn_type = __mlir_type[
        `(!pop.pointer<`, TaskGroup, `>) -> !lit.none`
    ]

    var callback: tg_callback_fn_type
    var task_group: Pointer[TaskGroup]


# FIXME(traits): This shouldn't be a register_passable type but we need this
# until we have traits for proper parametric types.
@register_passable
struct TaskGroup:
    var counter: Atomic[DType.index]
    var chain: Chain
    var rt: Runtime

    fn __init__(rt: Runtime) -> TaskGroup:
        var chain: Chain
        _init_llcl_chain(rt, Pointer[Chain].address_of(chain))
        return TaskGroup {counter: 1, chain: chain, rt: rt}

    fn __del__(self&):
        _del_llcl_chain(Pointer[Chain].address_of(self.chain))

    @always_inline
    fn _counter_decr(self&) -> Int:
        let prev: Int = self.counter.isub(1).value
        return prev - 1

    fn _task_complete(self&):
        if self._counter_decr() == 0:
            _async_complete(Pointer[Chain].address_of(self.chain))

    @staticmethod
    fn _get_complete_callback() -> __mlir_type[
        `(!pop.pointer<`, TaskGroup, `>) -> !lit.none`
    ]:
        return __mlir_op.`kgen.addressof`[
            _type : [
                __mlir_type[`(!pop.pointer<`, TaskGroup, `>) -> !lit.none`]
            ],
            callee:_task_complete,
            paramDecls : __mlir_attr.`#kgen<param.decls[]>`,
        ]()

    fn create_task[type: typename](self&, task: Coroutine[type]):
        self.counter += 1
        let task_group_txt = task.get_ctx[TaskGroupContext]()
        task_group_txt.store(
            TaskGroupContext {
                callback: _get_complete_callback(),
                task_group: Pointer[TaskGroup].address_of(self),
            }
        )
        _async_execute(task, self.rt)

    @staticmethod
    fn await_body_impl(
        hdl: __mlir_type.`!pop.pointer<i8>`, task_group&: TaskGroup
    ):
        _async_and_then(hdl, Pointer[Chain].address_of(task_group.chain))
        task_group._task_complete()

    @always_inline
    fn __await__(self&):
        let cur_hdl = __mlir_op.`pop.coroutine.opaque_handle`()

        __mlir_region await_body():
            await_body_impl(cur_hdl, self)

        __mlir_op.`pop.coroutine.await`[_region:["await_body"]]()

    fn wait(self&):
        self._task_complete()
        _async_wait(Pointer[Chain].address_of(self.chain))
