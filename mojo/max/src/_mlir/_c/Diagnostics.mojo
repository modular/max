# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #
#
# GENERATED FILE, DO NOT EDIT!
#
# Last generated by stef at 2024-01-12 08:19:31.796612 with command
# ```
#   ./utils/mojo-mlir/generate_mlir_c_bindings.sh \
#     Diagnostics.h
# ```
#
# ===----------------------------------------------------------------------=== #

from .ffi import MLIR_func
from .IR import MlirContext, MlirLocation, MlirStringRef
from .Support import MlirLogicalResult

# ===-- mlir-c/Diagnostics.h - MLIR Diagnostic subsystem C API ----*- C -*-===//
#
#  Part of the LLVM Project, under the Apache License v2.0 with LLVM
#  Exceptions.
#  See https://llvm.org/LICENSE.txt for license information.
#  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# ===----------------------------------------------------------------------===//
#
#  This header declares the C APIs accessing MLIR Diagnostics subsystem.
#
# ===----------------------------------------------------------------------===//


@register_passable("trivial")
struct MlirDiagnostic:
    """An opaque reference to a diagnostic, always owned by the diagnostics engine
    (context). Must not be stored outside of the diagnostic handler."""

    var ptr: Pointer[NoneType]


@register_passable("trivial")
struct MlirDiagnosticSeverity:
    """Severity of a diagnostic."""

    var value: Int8


alias MlirDiagnosticError = MlirDiagnosticSeverity {value: 0}
alias MlirDiagnosticWarning = MlirDiagnosticSeverity {value: 1}
alias MlirDiagnosticNote = MlirDiagnosticSeverity {value: 2}
alias MlirDiagnosticRemark = MlirDiagnosticSeverity {value: 3}

# Diagnostic handler type. Accepts a reference to a diagnostic, which is only
# guaranteed to be live during the call. The handler is passed the `userData`
# that was provided when the handler was attached to a context. If the handler
# processed the diagnostic completely, it is expected to return success.
# Otherwise, it is expected to return failure to indicate that other handlers
# should attempt to process the diagnostic.
alias MlirDiagnosticHandler = fn (
    MlirDiagnostic, Pointer[NoneType]
) -> MlirLogicalResult


fn mlirDiagnosticPrint(
    diagnostic: MlirDiagnostic,
    callback: fn (MlirStringRef, UnsafePointer[NoneType]) -> NoneType,
    user_data: UnsafePointer[NoneType],
) -> NoneType:
    """Prints a diagnostic using the provided callback."""
    return MLIR_func[
        "mlirDiagnosticPrint",
        fn (
            MlirDiagnostic,
            fn (MlirStringRef, UnsafePointer[NoneType]) -> NoneType,
            UnsafePointer[NoneType],
        ) -> NoneType,
    ]()(diagnostic, callback, user_data)


fn mlirDiagnosticGetLocation(diagnostic: MlirDiagnostic) -> MlirLocation:
    """Returns the location at which the diagnostic is reported."""
    return MLIR_func[
        "mlirDiagnosticGetLocation", fn (MlirDiagnostic) -> MlirLocation
    ]()(diagnostic)


fn mlirDiagnosticGetSeverity(
    diagnostic: MlirDiagnostic,
) -> MlirDiagnosticSeverity:
    """Returns the severity of the diagnostic."""
    return MLIR_func[
        "mlirDiagnosticGetSeverity",
        fn (MlirDiagnostic) -> MlirDiagnosticSeverity,
    ]()(diagnostic)


fn mlirDiagnosticGetNumNotes(diagnostic: MlirDiagnostic) -> Int:
    """Returns the number of notes attached to the diagnostic."""
    return MLIR_func["mlirDiagnosticGetNumNotes", fn (MlirDiagnostic) -> Int]()(
        diagnostic
    )


fn mlirDiagnosticGetNote(
    diagnostic: MlirDiagnostic, pos: Int
) -> MlirDiagnostic:
    """Returns `pos`-th note attached to the diagnostic. Expects `pos` to be a
    valid zero-based index into the list of notes."""
    return MLIR_func[
        "mlirDiagnosticGetNote", fn (MlirDiagnostic, Int) -> MlirDiagnostic
    ]()(diagnostic, pos)


#  Attaches the diagnostic handler to the context. Handlers are invoked in the
#  reverse order of attachment until one of them processes the diagnostic
#  completely. When a handler is invoked it is passed the `userData` that was
#  provided when it was attached. If non-NULL, `deleteUserData` is called once
#  the system no longer needs to call the handler (for instance after the
#  handler is detached or the context is destroyed). Returns an identifier that
#  can be used to detach the handler.


fn mlirContextAttachDiagnosticHandler(
    context: MlirContext,
    handler: fn (MlirDiagnostic, UnsafePointer[NoneType]) -> MlirLogicalResult,
    user_data: UnsafePointer[NoneType],
    delete_user_data: fn (UnsafePointer[NoneType]) -> NoneType,
) -> MlirDiagnosticHandlerID:
    """Attaches the diagnostic handler to the context. Handlers are invoked in the
    reverse order of attachment until one of them processes the diagnostic
    completely. When a handler is invoked it is passed the `userData` that was
    provided when it was attached. If non-NULL, `deleteUserData` is called once
    the system no longer needs to call the handler (for instance after the
    handler is detached or the context is destroyed). Returns an identifier that
    can be used to detach the handler."""
    return MLIR_func[
        "mlirContextAttachDiagnosticHandler",
        fn (
            MlirContext,
            fn (MlirDiagnostic, UnsafePointer[NoneType]) -> MlirLogicalResult,
            UnsafePointer[NoneType],
            fn (UnsafePointer[NoneType]) -> NoneType,
        ) -> MlirDiagnosticHandlerID,
    ]()(context, handler, user_data, delete_user_data)


fn mlirContextDetachDiagnosticHandler(
    context: MlirContext, id: MlirDiagnosticHandlerID
) -> NoneType:
    """Detaches an attached diagnostic handler from the context given its
    identifier."""
    return MLIR_func[
        "mlirContextDetachDiagnosticHandler",
        fn (MlirContext, MlirDiagnosticHandlerID) -> NoneType,
    ]()(context, id)


fn mlirEmitError(location: MlirLocation, message: Pointer[Int8]) -> NoneType:
    """Emits an error at the given location through the diagnostics engine. Used
    for testing purposes."""
    return MLIR_func[
        "mlirEmitError", fn (MlirLocation, Pointer[Int8]) -> NoneType
    ]()(location, message)


# ===----------------------------------------------------------------------=== #
#     Codegen: Remaining symbols
# ===----------------------------------------------------------------------=== #

# Opaque identifier of a diagnostic handler, useful to detach a handler.
alias MlirDiagnosticHandlerID = UInt64
