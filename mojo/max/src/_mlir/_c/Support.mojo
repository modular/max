# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #
#
# GENERATED FILE, DO NOT EDIT!
#
# Last generated by mathieu at 2024-07-16 20:51:42.697844 with command
# ```
#   ./utils/mojo/mlir-bindings/generate_mlir_c_bindings.sh \
#     Support.h
# ```
#
# ===----------------------------------------------------------------------=== #

from .ffi import MLIR_func

# ===-- mlir-c/Support.h - Helpers for C API to Core MLIR ---------*- C -*-===//
#
#  Part of the LLVM Project, under the Apache License v2.0 with LLVM
#  Exceptions.
#  See https://llvm.org/LICENSE.txt for license information.
#  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# ===----------------------------------------------------------------------===//
#
#  This header declares the auxiliary data structures used in C APIs to core
#  MLIR functionality.
#
# ===----------------------------------------------------------------------===//

# ===----------------------------------------------------------------------===//
#  Visibility annotations.
#  Use MLIR_CAPI_EXPORTED for exported functions.
#
#  On Windows, if MLIR_CAPI_ENABLE_WINDOWS_DLL_DECLSPEC is defined, then
#  __declspec(dllexport) and __declspec(dllimport) will be generated. This
#  can only be enabled if actually building DLLs. It is generally, mutually
#  exclusive with the use of other mechanisms for managing imports/exports
#  (i.e. CMake's WINDOWS_EXPORT_ALL_SYMBOLS feature).
# ===----------------------------------------------------------------------===//


@register_passable("trivial")
struct MlirLlvmThreadPool:
    """Re-export llvm::ThreadPool so as to avoid including the LLVM C API directly.
    """

    # Re-export llvm::ThreadPool so as to avoid including the LLVM C API directly.
    var ptr: UnsafePointer[NoneType]


@register_passable("trivial")
struct MlirTypeID:
    var ptr: UnsafePointer[NoneType]


@register_passable("trivial")
struct MlirTypeIDAllocator:
    var ptr: UnsafePointer[NoneType]


# ===----------------------------------------------------------------------===//
#  MlirStringRef.
# ===----------------------------------------------------------------------===//

#  A pointer to a sized fragment of a string, not necessarily null-terminated.
#  Does not own the underlying string. This is equivalent to llvm::StringRef.

# A pointer to a sized fragment of a string, not necessarily null-terminated.
# Does not own the underlying string. This is equivalent to llvm::StringRef.
alias MlirStringRef = StringRef

#  Constructs a string reference from the pointer and length. The pointer need
#  not reference to a null-terminated string.

# FIXEME(codegen): static function mlirStringRefCreate


fn mlirStringRefCreateFromCString(str: UnsafePointer[Int8]) -> MlirStringRef:
    """Constructs a string reference from a null-terminated C string. Prefer
    mlirStringRefCreate if the length of the string is known."""
    return MLIR_func["mlirStringRefCreateFromCString", MlirStringRef](str)


fn mlirStringRefEqual(string: MlirStringRef, other: MlirStringRef) -> Bool:
    """Returns true if two string references are equal, false otherwise."""
    return MLIR_func["mlirStringRefEqual", Bool](string, other)


# A callback for returning string references.
#
# This function is called back by the functions that need to return a
# reference to the portion of the string with the following arguments:
#  - an MlirStringRef representing the current portion of the string
#  - a pointer to user data forwarded from the printing call.
alias MlirStringCallback = fn (MlirStringRef, UnsafePointer[NoneType]) -> None

# ===----------------------------------------------------------------------===//
#  MlirLogicalResult.
# ===----------------------------------------------------------------------===//


@register_passable("trivial")
struct MlirLogicalResult:
    """A logical result value, essentially a boolean with named states. LLVM
    convention for using boolean values to designate success or failure of an
    operation is a moving target, so MLIR opted for an explicit class.
    Instances of MlirLogicalResult must only be inspected using the associated
    functions."""

    var value: Int8


# FIXEME(codegen): static function mlirLogicalResultIsSuccess

# FIXEME(codegen): static function mlirLogicalResultIsFailure

# FIXEME(codegen): static function mlirLogicalResultSuccess

# FIXEME(codegen): static function mlirLogicalResultFailure

# ===----------------------------------------------------------------------===//
#  MlirLlvmThreadPool.
# ===----------------------------------------------------------------------===//


fn mlirLlvmThreadPoolCreate() -> MlirLlvmThreadPool:
    """Create an LLVM thread pool. This is reexported here to avoid directly
    pulling in the LLVM headers directly."""
    return MLIR_func["mlirLlvmThreadPoolCreate", MlirLlvmThreadPool]()


fn mlirLlvmThreadPoolDestroy(pool: MlirLlvmThreadPool) -> None:
    """Destroy an LLVM thread pool."""
    return MLIR_func["mlirLlvmThreadPoolDestroy", NoneType._mlir_type](pool)


# ===----------------------------------------------------------------------===//
#  TypeID API.
# ===----------------------------------------------------------------------===//


fn mlirTypeIDCreate(ptr: UnsafePointer[NoneType]) -> MlirTypeID:
    """`ptr` must be 8 byte aligned and unique to a type valid for the duration of
    the returned type id's usage."""
    return MLIR_func["mlirTypeIDCreate", MlirTypeID](ptr)


# FIXEME(codegen): static function mlirTypeIDIsNull


fn mlirTypeIDEqual(type_id1: MlirTypeID, type_id2: MlirTypeID) -> Bool:
    """Checks if two type ids are equal."""
    return MLIR_func["mlirTypeIDEqual", Bool](type_id1, type_id2)


fn mlirTypeIDHashValue(type_id: MlirTypeID) -> Int:
    """Returns the hash value of the type id."""
    return MLIR_func["mlirTypeIDHashValue", Int](type_id)


# ===----------------------------------------------------------------------===//
#  TypeIDAllocator API.
# ===----------------------------------------------------------------------===//


fn mlirTypeIDAllocatorCreate() -> MlirTypeIDAllocator:
    """Creates a type id allocator for dynamic type id creation."""
    return MLIR_func["mlirTypeIDAllocatorCreate", MlirTypeIDAllocator]()


fn mlirTypeIDAllocatorDestroy(allocator: MlirTypeIDAllocator) -> None:
    """Deallocates the allocator and all allocated type ids."""
    return MLIR_func["mlirTypeIDAllocatorDestroy", NoneType._mlir_type](
        allocator
    )


fn mlirTypeIDAllocatorAllocateTypeID(
    allocator: MlirTypeIDAllocator,
) -> MlirTypeID:
    """Allocates a type id that is valid for the lifetime of the allocator."""
    return MLIR_func["mlirTypeIDAllocatorAllocateTypeID", MlirTypeID](allocator)
