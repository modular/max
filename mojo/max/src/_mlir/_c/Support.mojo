# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #
#
# GENERATED FILE, DO NOT EDIT!
#
# Last generated by stef at 2024-01-12 08:19:33.176814 with command
# ```
#   ./utils/mojo-mlir/generate_mlir_c_bindings.sh \
#     Support.h
# ```
#
# ===----------------------------------------------------------------------=== #

from .ffi import MLIR_func

# ===-- mlir-c/Support.h - Helpers for C API to Core MLIR ---------*- C -*-===//
#
#  Part of the LLVM Project, under the Apache License v2.0 with LLVM
#  Exceptions.
#  See https://llvm.org/LICENSE.txt for license information.
#  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# ===----------------------------------------------------------------------===//
#
#  This header declares the auxiliary data structures used in C APIs to core
#  MLIR functionality.
#
# ===----------------------------------------------------------------------===//

# ===----------------------------------------------------------------------===//
#  Visibility annotations.
#  Use MLIR_CAPI_EXPORTED for exported functions.
#
#  On Windows, if MLIR_CAPI_ENABLE_WINDOWS_DLL_DECLSPEC is defined, then
#  __declspec(dllexport) and __declspec(dllimport) will be generated. This
#  can only be enabled if actually building DLLs. It is generally, mutually
#  exclusive with the use of other mechanisms for managing imports/exports
#  (i.e. CMake's WINDOWS_EXPORT_ALL_SYMBOLS feature).
# ===----------------------------------------------------------------------===//


@register_passable("trivial")
struct MlirLlvmThreadPool:
    """Re-export llvm::ThreadPool so as to avoid including the LLVM C API directly.
    """

    var ptr: Pointer[NoneType]


@register_passable("trivial")
struct MlirTypeID:
    var ptr: Pointer[NoneType]


@register_passable("trivial")
struct MlirTypeIDAllocator:
    var ptr: Pointer[NoneType]


# ===----------------------------------------------------------------------===//
#  MlirStringRef.
# ===----------------------------------------------------------------------===//

#  A pointer to a sized fragment of a string, not necessarily null-terminated.
#  Does not own the underlying string. This is equivalent to llvm::StringRef.

# A pointer to a sized fragment of a string, not necessarily null-terminated.
# Does not own the underlying string. This is equivalent to llvm::StringRef.
alias MlirStringRef = StringRef

#  Constructs a string reference from the pointer and length. The pointer need
#  not reference to a null-terminated string.

# FIXEME(codegen): static function mlirStringRefCreate


fn mlirStringRefCreateFromCString(str: Pointer[Int8]) -> MlirStringRef:
    """Constructs a string reference from a null-terminated C string. Prefer
    mlirStringRefCreate if the length of the string is known."""
    return MLIR_func[
        "mlirStringRefCreateFromCString", fn (Pointer[Int8]) -> MlirStringRef
    ]()(str)


fn mlirStringRefEqual(string: MlirStringRef, other: MlirStringRef) -> Bool:
    """Returns true if two string references are equal, false otherwise."""
    return MLIR_func[
        "mlirStringRefEqual", fn (MlirStringRef, MlirStringRef) -> Bool
    ]()(string, other)


# A callback for returning string references.
#
# This function is called back by the functions that need to return a
# reference to the portion of the string with the following arguments:
#  - an MlirStringRef representing the current portion of the string
#  - a pointer to user data forwarded from the printing call.
alias MlirStringCallback = fn (
    MlirStringRef, UnsafePointer[NoneType]
) -> NoneType

# ===----------------------------------------------------------------------===//
#  MlirLogicalResult.
# ===----------------------------------------------------------------------===//


@register_passable("trivial")
struct MlirLogicalResult:
    """A logical result value, essentially a boolean with named states. LLVM
    convention for using boolean values to designate success or failure of an
    operation is a moving target, so MLIR opted for an explicit class.
    Instances of MlirLogicalResult must only be inspected using the associated
    functions."""

    var value: Int8


# FIXEME(codegen): static function mlirLogicalResultIsSuccess

# FIXEME(codegen): static function mlirLogicalResultIsFailure

# FIXEME(codegen): static function mlirLogicalResultSuccess

# FIXEME(codegen): static function mlirLogicalResultFailure

# ===----------------------------------------------------------------------===//
#  MlirLlvmThreadPool.
# ===----------------------------------------------------------------------===//


fn mlirLlvmThreadPoolCreate() -> MlirLlvmThreadPool:
    """Create an LLVM thread pool. This is reexported here to avoid directly
    pulling in the LLVM headers directly."""
    return MLIR_func[
        "mlirLlvmThreadPoolCreate", fn () -> MlirLlvmThreadPool
    ]()()


fn mlirLlvmThreadPoolDestroy(pool: MlirLlvmThreadPool) -> NoneType:
    """Destroy an LLVM thread pool."""
    return MLIR_func[
        "mlirLlvmThreadPoolDestroy", fn (MlirLlvmThreadPool) -> NoneType
    ]()(pool)


# ===----------------------------------------------------------------------===//
#  TypeID API.
# ===----------------------------------------------------------------------===//


fn mlirTypeIDCreate(ptr: Pointer[NoneType]) -> MlirTypeID:
    """`ptr` must be 8 byte aligned and unique to a type valid for the duration of
    the returned type id's usage."""
    return MLIR_func[
        "mlirTypeIDCreate", fn (Pointer[NoneType]) -> MlirTypeID
    ]()(ptr)


# FIXEME(codegen): static function mlirTypeIDIsNull


fn mlirTypeIDEqual(type_id1: MlirTypeID, type_id2: MlirTypeID) -> Bool:
    """Checks if two type ids are equal."""
    return MLIR_func["mlirTypeIDEqual", fn (MlirTypeID, MlirTypeID) -> Bool]()(
        type_id1, type_id2
    )


fn mlirTypeIDHashValue(type_id: MlirTypeID) -> Int:
    """Returns the hash value of the type id."""
    return MLIR_func["mlirTypeIDHashValue", fn (MlirTypeID) -> Int]()(type_id)


# ===----------------------------------------------------------------------===//
#  TypeIDAllocator API.
# ===----------------------------------------------------------------------===//


fn mlirTypeIDAllocatorCreate() -> MlirTypeIDAllocator:
    """Creates a type id allocator for dynamic type id creation."""
    return MLIR_func[
        "mlirTypeIDAllocatorCreate", fn () -> MlirTypeIDAllocator
    ]()()


fn mlirTypeIDAllocatorDestroy(allocator: MlirTypeIDAllocator) -> NoneType:
    """Deallocates the allocator and all allocated type ids."""
    return MLIR_func[
        "mlirTypeIDAllocatorDestroy", fn (MlirTypeIDAllocator) -> NoneType
    ]()(allocator)


fn mlirTypeIDAllocatorAllocateTypeID(
    allocator: MlirTypeIDAllocator,
) -> MlirTypeID:
    """Allocates a type id that is valid for the lifetime of the allocator."""
    return MLIR_func[
        "mlirTypeIDAllocatorAllocateTypeID",
        fn (MlirTypeIDAllocator) -> MlirTypeID,
    ]()(allocator)
