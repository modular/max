# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #
#
# GENERATED FILE, DO NOT EDIT!
#
# Last generated by stef at 2024-01-12 08:19:30.461408 with command
# ```
#   ./utils/mojo-mlir/generate_mlir_c_bindings.sh \
#     AffineExpr.h
# ```
#
# ===----------------------------------------------------------------------=== #

from .ffi import MLIR_func
from .AffineMap import MlirAffineMap

# ===-- mlir-c/AffineExpr.h - C API for MLIR Affine Expressions ---*- C -*-===//
#
#  Part of the LLVM Project, under the Apache License v2.0 with LLVM
#  Exceptions.
#  See https://llvm.org/LICENSE.txt for license information.
#  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# ===----------------------------------------------------------------------===//

from .IR import MlirContext
from .Support import MlirStringRef

# ===----------------------------------------------------------------------===//
#  Opaque type declarations.
#
#  Types are exposed to C bindings as structs containing opaque pointers. They
#  are not supposed to be inspected from C. This allows the underlying
#  representation to change without affecting the API users. The use of structs
#  instead of typedefs enables some type safety as structs are not implicitly
#  convertible to each other.
#
#  Instances of these types may or may not own the underlying object. The
#  ownership semantics is defined by how an instance of the type was obtained.
# ===----------------------------------------------------------------------===//


@register_passable("trivial")
struct MlirAffineExpr:
    var ptr: Pointer[NoneType]


fn mlirAffineExprGetContext(affine_expr: MlirAffineExpr) -> MlirContext:
    """Gets the context that owns the affine expression."""
    return MLIR_func[
        "mlirAffineExprGetContext", fn (MlirAffineExpr) -> MlirContext
    ]()(affine_expr)


fn mlirAffineExprEqual(lhs: MlirAffineExpr, rhs: MlirAffineExpr) -> Bool:
    """Returns `true` if the two affine expressions are equal."""
    return MLIR_func[
        "mlirAffineExprEqual", fn (MlirAffineExpr, MlirAffineExpr) -> Bool
    ]()(lhs, rhs)


# FIXEME(codegen): static function mlirAffineExprIsNull


fn mlirAffineExprPrint(
    affine_expr: MlirAffineExpr,
    callback: fn (MlirStringRef, Pointer[NoneType]) -> NoneType,
    user_data: Pointer[NoneType],
) -> NoneType:
    """Prints an affine expression by sending chunks of the string representation
    and forwarding `userData to `callback`. Note that the callback may be called
    several times with consecutive chunks of the string."""
    return MLIR_func[
        "mlirAffineExprPrint",
        fn (
            MlirAffineExpr,
            fn (MlirStringRef, Pointer[NoneType]) -> NoneType,
            Pointer[NoneType],
        ) -> NoneType,
    ]()(affine_expr, callback, user_data)


fn mlirAffineExprDump(affine_expr: MlirAffineExpr) -> NoneType:
    """Prints the affine expression to the standard error stream."""
    return MLIR_func["mlirAffineExprDump", fn (MlirAffineExpr) -> NoneType]()(
        affine_expr
    )


fn mlirAffineExprIsSymbolicOrConstant(affine_expr: MlirAffineExpr) -> Bool:
    """Checks whether the given affine expression is made out of only symbols and
    constants."""
    return MLIR_func[
        "mlirAffineExprIsSymbolicOrConstant", fn (MlirAffineExpr) -> Bool
    ]()(affine_expr)


fn mlirAffineExprIsPureAffine(affine_expr: MlirAffineExpr) -> Bool:
    """Checks whether the given affine expression is a pure affine expression, i.e.
    mul, floordiv, ceildic, and mod is only allowed w.r.t constants."""
    return MLIR_func[
        "mlirAffineExprIsPureAffine", fn (MlirAffineExpr) -> Bool
    ]()(affine_expr)


fn mlirAffineExprGetLargestKnownDivisor(affine_expr: MlirAffineExpr) -> Int64:
    """Returns the greatest known integral divisor of this affine expression. The
    result is always positive."""
    return MLIR_func[
        "mlirAffineExprGetLargestKnownDivisor", fn (MlirAffineExpr) -> Int64
    ]()(affine_expr)


fn mlirAffineExprIsMultipleOf(
    affine_expr: MlirAffineExpr, factor: Int64
) -> Bool:
    """Checks whether the given affine expression is a multiple of 'factor'."""
    return MLIR_func[
        "mlirAffineExprIsMultipleOf", fn (MlirAffineExpr, Int64) -> Bool
    ]()(affine_expr, factor)


fn mlirAffineExprIsFunctionOfDim(
    affine_expr: MlirAffineExpr, position: Int
) -> Bool:
    """Checks whether the given affine expression involves AffineDimExpr
    'position'."""
    return MLIR_func[
        "mlirAffineExprIsFunctionOfDim", fn (MlirAffineExpr, Int) -> Bool
    ]()(affine_expr, position)


fn mlirAffineExprCompose(
    affine_expr: MlirAffineExpr, affine_map: MlirAffineMap
) -> MlirAffineExpr:
    """Composes the given map with the given expression."""
    return MLIR_func[
        "mlirAffineExprCompose",
        fn (MlirAffineExpr, MlirAffineMap) -> MlirAffineExpr,
    ]()(affine_expr, affine_map)


# ===----------------------------------------------------------------------===//
#  Affine Dimension Expression.
# ===----------------------------------------------------------------------===//


fn mlirAffineExprIsADim(affine_expr: MlirAffineExpr) -> Bool:
    """Checks whether the given affine expression is a dimension expression."""
    return MLIR_func["mlirAffineExprIsADim", fn (MlirAffineExpr) -> Bool]()(
        affine_expr
    )


fn mlirAffineDimExprGet(ctx: MlirContext, position: Int) -> MlirAffineExpr:
    """Creates an affine dimension expression with 'position' in the context."""
    return MLIR_func[
        "mlirAffineDimExprGet", fn (MlirContext, Int) -> MlirAffineExpr
    ]()(ctx, position)


fn mlirAffineDimExprGetPosition(affine_expr: MlirAffineExpr) -> Int:
    """Returns the position of the given affine dimension expression."""
    return MLIR_func[
        "mlirAffineDimExprGetPosition", fn (MlirAffineExpr) -> Int
    ]()(affine_expr)


# ===----------------------------------------------------------------------===//
#  Affine Symbol Expression.
# ===----------------------------------------------------------------------===//


fn mlirAffineExprIsASymbol(affine_expr: MlirAffineExpr) -> Bool:
    """Checks whether the given affine expression is a symbol expression."""
    return MLIR_func["mlirAffineExprIsASymbol", fn (MlirAffineExpr) -> Bool]()(
        affine_expr
    )


fn mlirAffineSymbolExprGet(ctx: MlirContext, position: Int) -> MlirAffineExpr:
    """Creates an affine symbol expression with 'position' in the context."""
    return MLIR_func[
        "mlirAffineSymbolExprGet", fn (MlirContext, Int) -> MlirAffineExpr
    ]()(ctx, position)


fn mlirAffineSymbolExprGetPosition(affine_expr: MlirAffineExpr) -> Int:
    """Returns the position of the given affine symbol expression."""
    return MLIR_func[
        "mlirAffineSymbolExprGetPosition", fn (MlirAffineExpr) -> Int
    ]()(affine_expr)


# ===----------------------------------------------------------------------===//
#  Affine Constant Expression.
# ===----------------------------------------------------------------------===//


fn mlirAffineExprIsAConstant(affine_expr: MlirAffineExpr) -> Bool:
    """Checks whether the given affine expression is a constant expression."""
    return MLIR_func[
        "mlirAffineExprIsAConstant", fn (MlirAffineExpr) -> Bool
    ]()(affine_expr)


fn mlirAffineConstantExprGet(
    ctx: MlirContext, constant: Int64
) -> MlirAffineExpr:
    """Creates an affine constant expression with 'constant' in the context."""
    return MLIR_func[
        "mlirAffineConstantExprGet", fn (MlirContext, Int64) -> MlirAffineExpr
    ]()(ctx, constant)


fn mlirAffineConstantExprGetValue(affine_expr: MlirAffineExpr) -> Int64:
    """Returns the value of the given affine constant expression."""
    return MLIR_func[
        "mlirAffineConstantExprGetValue", fn (MlirAffineExpr) -> Int64
    ]()(affine_expr)


# ===----------------------------------------------------------------------===//
#  Affine Add Expression.
# ===----------------------------------------------------------------------===//


fn mlirAffineExprIsAAdd(affine_expr: MlirAffineExpr) -> Bool:
    """Checks whether the given affine expression is an add expression."""
    return MLIR_func["mlirAffineExprIsAAdd", fn (MlirAffineExpr) -> Bool]()(
        affine_expr
    )


fn mlirAffineAddExprGet(
    lhs: MlirAffineExpr, rhs: MlirAffineExpr
) -> MlirAffineExpr:
    """Creates an affine add expression with 'lhs' and 'rhs'."""
    return MLIR_func[
        "mlirAffineAddExprGet",
        fn (MlirAffineExpr, MlirAffineExpr) -> MlirAffineExpr,
    ]()(lhs, rhs)


# ===----------------------------------------------------------------------===//
#  Affine Mul Expression.
# ===----------------------------------------------------------------------===//


fn mlirAffineExprIsAMul(affine_expr: MlirAffineExpr) -> Bool:
    """Checks whether the given affine expression is an mul expression."""
    return MLIR_func["mlirAffineExprIsAMul", fn (MlirAffineExpr) -> Bool]()(
        affine_expr
    )


fn mlirAffineMulExprGet(
    lhs: MlirAffineExpr, rhs: MlirAffineExpr
) -> MlirAffineExpr:
    """Creates an affine mul expression with 'lhs' and 'rhs'."""
    return MLIR_func[
        "mlirAffineMulExprGet",
        fn (MlirAffineExpr, MlirAffineExpr) -> MlirAffineExpr,
    ]()(lhs, rhs)


# ===----------------------------------------------------------------------===//
#  Affine Mod Expression.
# ===----------------------------------------------------------------------===//


fn mlirAffineExprIsAMod(affine_expr: MlirAffineExpr) -> Bool:
    """Checks whether the given affine expression is an mod expression."""
    return MLIR_func["mlirAffineExprIsAMod", fn (MlirAffineExpr) -> Bool]()(
        affine_expr
    )


fn mlirAffineModExprGet(
    lhs: MlirAffineExpr, rhs: MlirAffineExpr
) -> MlirAffineExpr:
    """Creates an affine mod expression with 'lhs' and 'rhs'."""
    return MLIR_func[
        "mlirAffineModExprGet",
        fn (MlirAffineExpr, MlirAffineExpr) -> MlirAffineExpr,
    ]()(lhs, rhs)


# ===----------------------------------------------------------------------===//
#  Affine FloorDiv Expression.
# ===----------------------------------------------------------------------===//


fn mlirAffineExprIsAFloorDiv(affine_expr: MlirAffineExpr) -> Bool:
    """Checks whether the given affine expression is an floordiv expression."""
    return MLIR_func[
        "mlirAffineExprIsAFloorDiv", fn (MlirAffineExpr) -> Bool
    ]()(affine_expr)


fn mlirAffineFloorDivExprGet(
    lhs: MlirAffineExpr, rhs: MlirAffineExpr
) -> MlirAffineExpr:
    """Creates an affine floordiv expression with 'lhs' and 'rhs'."""
    return MLIR_func[
        "mlirAffineFloorDivExprGet",
        fn (MlirAffineExpr, MlirAffineExpr) -> MlirAffineExpr,
    ]()(lhs, rhs)


# ===----------------------------------------------------------------------===//
#  Affine CeilDiv Expression.
# ===----------------------------------------------------------------------===//


fn mlirAffineExprIsACeilDiv(affine_expr: MlirAffineExpr) -> Bool:
    """Checks whether the given affine expression is an ceildiv expression."""
    return MLIR_func["mlirAffineExprIsACeilDiv", fn (MlirAffineExpr) -> Bool]()(
        affine_expr
    )


fn mlirAffineCeilDivExprGet(
    lhs: MlirAffineExpr, rhs: MlirAffineExpr
) -> MlirAffineExpr:
    """Creates an affine ceildiv expression with 'lhs' and 'rhs'."""
    return MLIR_func[
        "mlirAffineCeilDivExprGet",
        fn (MlirAffineExpr, MlirAffineExpr) -> MlirAffineExpr,
    ]()(lhs, rhs)


# ===----------------------------------------------------------------------===//
#  Affine Binary Operation Expression.
# ===----------------------------------------------------------------------===//


fn mlirAffineExprIsABinary(affine_expr: MlirAffineExpr) -> Bool:
    """Checks whether the given affine expression is binary."""
    return MLIR_func["mlirAffineExprIsABinary", fn (MlirAffineExpr) -> Bool]()(
        affine_expr
    )


fn mlirAffineBinaryOpExprGetLHS(affine_expr: MlirAffineExpr) -> MlirAffineExpr:
    """Returns the left hand side affine expression of the given affine binary
    operation expression."""
    return MLIR_func[
        "mlirAffineBinaryOpExprGetLHS", fn (MlirAffineExpr) -> MlirAffineExpr
    ]()(affine_expr)


fn mlirAffineBinaryOpExprGetRHS(affine_expr: MlirAffineExpr) -> MlirAffineExpr:
    """Returns the right hand side affine expression of the given affine binary
    operation expression."""
    return MLIR_func[
        "mlirAffineBinaryOpExprGetRHS", fn (MlirAffineExpr) -> MlirAffineExpr
    ]()(affine_expr)
